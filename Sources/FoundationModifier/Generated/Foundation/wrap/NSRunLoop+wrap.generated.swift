
// Generated file
// DO NOT EDIT THIS FILE

#if canImport(Foundation)
import Foundation

extension Modify.DynamicMemberWrap where T: RunLoop {

    @_unavailableFromAsync(message: "acceptInput(for:before:) cannot be used from async contexts.")
    public func acceptInput(forMode mode: Foundation.RunLoop.Mode, before limitDate: Foundation.Date) -> Self {
        self.value.acceptInput(forMode: mode, before: limitDate)
        return Modify.DynamicMemberWrap(self.value)
    }

    @discardableResult
    public func add(_ aPort: Foundation.Port, forMode mode: Foundation.RunLoop.Mode) -> Self {
        self.value.add(aPort, forMode: mode)
        return Modify.DynamicMemberWrap(self.value)
    }

    @discardableResult
    public func add(_ timer: Foundation.Timer, forMode mode: Foundation.RunLoop.Mode) -> Self {
        self.value.add(timer, forMode: mode)
        return Modify.DynamicMemberWrap(self.value)
    }

    @discardableResult
    public func cancelPerform(_ aSelector: ObjectiveC.Selector, target: Any, argument arg: Any?) -> Self {
        self.value.cancelPerform(aSelector, target: target, argument: arg)
        return Modify.DynamicMemberWrap(self.value)
    }

    @discardableResult
    public func cancelPerformSelectors(withTarget target: Any) -> Self {
        self.value.cancelPerformSelectors(withTarget: target)
        return Modify.DynamicMemberWrap(self.value)
    }

    @discardableResult
    public func perform(_ aSelector: ObjectiveC.Selector, target: Any, argument arg: Any?, order: Swift.Int, modes: [Foundation.RunLoop.Mode]) -> Self {
        self.value.perform(aSelector, target: target, argument: arg, order: order, modes: modes)
        return Modify.DynamicMemberWrap(self.value)
    }

    @available(macOS 10.12, *)
    @discardableResult
    public func perform(_ block: @escaping @Sendable () -> Swift.Void) -> Self {
        self.value.perform(block)
        return Modify.DynamicMemberWrap(self.value)
    }

    @available(macOS 10.12, *)
    @discardableResult
    public func perform(inModes modes: [Foundation.RunLoop.Mode], block: @escaping @Sendable () -> Swift.Void) -> Self {
        self.value.perform(inModes: modes, block: block)
        return Modify.DynamicMemberWrap(self.value)
    }

    @discardableResult
    public func remove(_ aPort: Foundation.Port, forMode mode: Foundation.RunLoop.Mode) -> Self {
        self.value.remove(aPort, forMode: mode)
        return Modify.DynamicMemberWrap(self.value)
    }

    @_unavailableFromAsync(message: "run cannot be used from async contexts.")
    public func run() -> Self {
        self.value.run()
        return Modify.DynamicMemberWrap(self.value)
    }

    @_unavailableFromAsync(message: "run(until:) cannot be used from async contexts.")
    public func run(until limitDate: Foundation.Date) -> Self {
        self.value.run(until: limitDate)
        return Modify.DynamicMemberWrap(self.value)
    }

    @available(iOS 13.0, *)
    @available(macOS 10.15, *)
    @discardableResult
    public func schedule(after date: Foundation.RunLoop.SchedulerTimeType, tolerance: Foundation.RunLoop.SchedulerTimeType.Stride, options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> Self {
        self.value.schedule(after: date, tolerance: tolerance, options: options, action)
        return Modify.DynamicMemberWrap(self.value)
    }

    @available(iOS 13.0, *)
    @available(macOS 10.15, *)
    @discardableResult
    public func schedule(options: Foundation.RunLoop.SchedulerOptions?, _ action: @escaping () -> Swift.Void) -> Self {
        self.value.schedule(options: options, action)
        return Modify.DynamicMemberWrap(self.value)
    }

}


@available(macOS, unavailable)
extension Modify.DynamicMemberWrap where T: RunLoop {
    
}


@available(iOS, unavailable)
extension Modify.DynamicMemberWrap where T: RunLoop {

}

#endif

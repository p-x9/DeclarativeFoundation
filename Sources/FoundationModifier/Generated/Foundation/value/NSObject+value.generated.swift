
// Generated file
// DO NOT EDIT THIS FILE

#if canImport(Foundation)
import Foundation

@available(macOS 10.0, *)
@available(iOS 2.0, *)
extension Modify.DynamicMemberWrap where T: NSObject {

    @discardableResult
    @_disfavoredOverload
    public func addObserver(_ observer: ObjectiveC.NSObject, forKeyPath keyPath: Swift.String, options: Foundation.NSKeyValueObservingOptions = [], context: Swift.UnsafeMutableRawPointer?) -> T {
        self.value.addObserver(observer, forKeyPath: keyPath, options: options, context: context)
        return self.value
    }

    @discardableResult
    @_disfavoredOverload
    public func attemptRecovery(fromError error: Swift.Error, optionIndex recoveryOptionIndex: Swift.Int, delegate: Any?, didRecoverSelector: ObjectiveC.Selector?, contextInfo: Swift.UnsafeMutableRawPointer?) -> T {
        self.value.attemptRecovery(fromError: error, optionIndex: recoveryOptionIndex, delegate: delegate, didRecoverSelector: didRecoverSelector, contextInfo: contextInfo)
        return self.value
    }

    @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.")
    public func didChange(_ changeKind: Foundation.NSKeyValueChange, valuesAt indexes: Foundation.IndexSet, forKey key: Swift.String) -> T {
        self.value.didChange(changeKind, valuesAt: indexes, forKey: key)
        return self.value
    }

    @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.")
    public func didChangeValue(forKey key: Swift.String) -> T {
        self.value.didChangeValue(forKey: key)
        return self.value
    }

    @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.")
    public func didChangeValue(forKey key: Swift.String, withSetMutation mutationKind: Foundation.NSKeyValueSetMutationKind, using objects: Swift.Set<Swift.AnyHashable>) -> T {
        self.value.didChangeValue(forKey: key, withSetMutation: mutationKind, using: objects)
        return self.value
    }

    @discardableResult
    @_disfavoredOverload
    public func doesNotRecognizeSelector(_ aSelector: ObjectiveC.Selector!) -> T {
        self.value.doesNotRecognizeSelector(aSelector)
        return self.value
    }

    @available(*, deprecated, message: "Objective-C garbage collection is no longer supported")
    @available(*, deprecated, message: "Objective-C garbage collection is no longer supported")
    public func finalize() -> T {
        self.value.finalize()
        return self.value
    }

    @discardableResult
    @_disfavoredOverload
    public func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?) -> T {
        self.value.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)
        return self.value
    }

    @available(macOS 10.5, *)
    @_unavailableFromAsync(message: "Asynchronous work should be called from isolation from an actor")
    public func perform(_ aSelector: ObjectiveC.Selector, on thr: Foundation.Thread, with arg: Any?, waitUntilDone wait: Swift.Bool) -> T {
        self.value.perform(aSelector, on: thr, with: arg, waitUntilDone: wait)
        return self.value
    }

    @available(macOS 10.5, *)
    @_unavailableFromAsync(message: "Asynchronous work should be called from isolation from an actor")
    public func perform(_ aSelector: ObjectiveC.Selector, on thr: Foundation.Thread, with arg: Any?, waitUntilDone wait: Swift.Bool, modes array: [Swift.String]?) -> T {
        self.value.perform(aSelector, on: thr, with: arg, waitUntilDone: wait, modes: array)
        return self.value
    }

    @discardableResult
    @_disfavoredOverload
    public func perform(_ aSelector: ObjectiveC.Selector, with anArgument: Any?, afterDelay delay: Foundation.TimeInterval) -> T {
        self.value.perform(aSelector, with: anArgument, afterDelay: delay)
        return self.value
    }

    @discardableResult
    @_disfavoredOverload
    public func perform(_ aSelector: ObjectiveC.Selector, with anArgument: Any?, afterDelay delay: Foundation.TimeInterval, inModes modes: [Foundation.RunLoop.Mode]) -> T {
        self.value.perform(aSelector, with: anArgument, afterDelay: delay, inModes: modes)
        return self.value
    }

    @available(macOS 10.5, *)
    @discardableResult
    @_disfavoredOverload
    public func performSelector(inBackground aSelector: ObjectiveC.Selector, with arg: Any?) -> T {
        self.value.performSelector(inBackground: aSelector, with: arg)
        return self.value
    }

    @_unavailableFromAsync(message: "Work intended for the main actor should be marked with @MainActor")
    public func performSelector(onMainThread aSelector: ObjectiveC.Selector, with arg: Any?, waitUntilDone wait: Swift.Bool) -> T {
        self.value.performSelector(onMainThread: aSelector, with: arg, waitUntilDone: wait)
        return self.value
    }

    @_unavailableFromAsync(message: "Work intended for the main actor should be marked with @MainActor")
    public func performSelector(onMainThread aSelector: ObjectiveC.Selector, with arg: Any?, waitUntilDone wait: Swift.Bool, modes array: [Swift.String]?) -> T {
        self.value.performSelector(onMainThread: aSelector, with: arg, waitUntilDone: wait, modes: array)
        return self.value
    }

    @discardableResult
    @_disfavoredOverload
    public func removeObserver(_ observer: ObjectiveC.NSObject, forKeyPath keyPath: Swift.String) -> T {
        self.value.removeObserver(observer, forKeyPath: keyPath)
        return self.value
    }

    @available(macOS 10.7, *)
    @discardableResult
    @_disfavoredOverload
    public func removeObserver(_ observer: ObjectiveC.NSObject, forKeyPath keyPath: Swift.String, context: Swift.UnsafeMutableRawPointer?) -> T {
        self.value.removeObserver(observer, forKeyPath: keyPath, context: context)
        return self.value
    }

    @discardableResult
    @_disfavoredOverload
    public func setNilValueForKey(_ key: Swift.String) -> T {
        self.value.setNilValueForKey(key)
        return self.value
    }

    @discardableResult
    @_disfavoredOverload
    public func setValue(_ value: Any?, forKey key: Swift.String) -> T {
        self.value.setValue(value, forKey: key)
        return self.value
    }

    @discardableResult
    @_disfavoredOverload
    public func setValue(_ value: Any?, forKeyPath keyPath: Swift.String) -> T {
        self.value.setValue(value, forKeyPath: keyPath)
        return self.value
    }

    @discardableResult
    @_disfavoredOverload
    public func setValue(_ value: Any?, forUndefinedKey key: Swift.String) -> T {
        self.value.setValue(value, forUndefinedKey: key)
        return self.value
    }

    @discardableResult
    @_disfavoredOverload
    public func setValuesForKeys(_ keyedValues: [Swift.String : Any]) -> T {
        self.value.setValuesForKeys(keyedValues)
        return self.value
    }

    @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.")
    public func willChange(_ changeKind: Foundation.NSKeyValueChange, valuesAt indexes: Foundation.IndexSet, forKey key: Swift.String) -> T {
        self.value.willChange(changeKind, valuesAt: indexes, forKey: key)
        return self.value
    }

    @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.")
    public func willChangeValue(forKey key: Swift.String) -> T {
        self.value.willChangeValue(forKey: key)
        return self.value
    }

    @_unavailableFromAsync(message: "Only notify of changes to a key in a synchronous context. Notifying changes across suspension points has undefined behavior.")
    public func willChangeValue(forKey key: Swift.String, withSetMutation mutationKind: Foundation.NSKeyValueSetMutationKind, using objects: Swift.Set<Swift.AnyHashable>) -> T {
        self.value.willChangeValue(forKey: key, withSetMutation: mutationKind, using: objects)
        return self.value
    }

}

@available(iOS 2.0, *)
@available(macOS, unavailable)
extension Modify.DynamicMemberWrap where T: NSObject {
    
}

@available(macOS 10.0, *)
@available(iOS, unavailable)
extension Modify.DynamicMemberWrap where T: NSObject {

}

#endif
